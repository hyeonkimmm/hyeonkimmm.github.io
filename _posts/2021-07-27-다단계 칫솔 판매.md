---
title : "[프로그래머스] 다단계 칫솔판매"
category :
    - python
tag :
    - programmers
toc : true
published : true
---

## [다단계 칫솔판매](https://programmers.co.kr/learn/courses/30/lessons/77486)

- 2021 Dev-Matching: 웹 백엔드 개발자(상반기)

### 문제 설명
- 다단계 조직
- 민호가 최상위
- 다단계 조직에 참가시킨 친구는 10%의 배당금을 받음
- 배당금이 1 미만이면 그대로 다 가짐
### 제한사항
- enroll의 길이는 1 이상 10,000 이하입니다.
- enroll에 민호의 이름은 없습니다. 따라서 enroll의 길이는 민호를 제외한 조직 구성원의 총 수입니다.
- referral의 길이는 enroll의 길이와 같습니다.
referral 내에서 i 번째에 있는 이름은 배열 enroll 내에서 i 번째에 있는 판매원을 조직에 참여시킨 사람의 - 이름입니다.
어느 누구의 추천도 없이 조직에 참여한 사람에 대해서는 referral 배열 내에 추천인의 이름이 기입되지 - 않고 “-“ 가 기입됩니다. 위 예제에서는 john 과 mary 가 이러한 예에 해당합니다.
- enroll 에 등장하는 이름은 조직에 참여한 순서에 따릅니다.
즉, 어느 판매원의 이름이 enroll 의 i 번째에 등장한다면, 이 판매원을 조직에 참여시킨 사람의 이름, 즉 - referral 의 i 번째 원소는 이미 배열 enroll 의 j 번째 (j < i) 에 등장했음이 보장됩니다.
- seller의 길이는 1 이상 100,000 이하입니다.
- seller 내의 i 번째에 있는 이름은 i 번째 판매 집계 데이터가 어느 판매원에 의한 것인지를 나타냅니다.
- seller 에는 같은 이름이 중복해서 들어있을 수 있습니다.
- amount의 길이는 seller의 길이와 같습니다.
- amount 내의 i 번째에 있는 수는 i 번째 판매 집계 데이터의 판매량을 나타냅니다.
- 판매량의 범위, 즉 amount 의 원소들의 범위는 1 이상 100 이하인 자연수입니다.
- 칫솔 한 개를 판매하여 얻어지는 이익은 100 원으로 정해져 있습니다.
- 모든 조직 구성원들의 이름은 10 글자 이내의 영문 알파벳 소문자들로만 이루어져 있습니다.
---
### 풀이
>  다른 풀이 방법도 있겠지만 dict와 재귀함수를 사용하는 게 가장 먼저 떠오름 dfs 방식을 생각해도 될 듯
```python
def cal_dividend(seller,amount,member_dict={}):
    dividend = int(amount*0.1)
    # 배당금 10% 1미만
    if dividend < 1 :
        member_dict[seller][1] += amount # 그대로 순이익
    # 배당금 10% 1이상 and 추천인 X
    elif member_dict[seller][0] =='-':
        member_dict[seller][1] += amount - dividend
    # 배당금 10% 1이상 and 추천인 O
    else:
        member_dict[seller][1] += amount - dividend
        cal_dividend(member_dict[seller][0],dividend,member_dict)

def solution(enroll, referral, seller, amount):
    member_dict = {}
    for en,re in zip(enroll,referral):
        member_dict[en]=[re,0]
    amount = list(map(lambda x:x*100,amount))
    for sellery,count in zip(seller,amount):
        cal_dividend(sellery, count,member_dict)
    answer = []
    for member in enroll:
        answer.append(member_dict[member][1])
    return answer
```